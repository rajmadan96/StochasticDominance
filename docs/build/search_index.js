var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"```@docs StochasticDominanceMeanReturn StochasticDominanceRiskMeasure AuxiliaryFunc.safeexponent AuxiliaryFunc.simplex1 AuxiliaryFunc.simplex2 AuxiliaryFunc.gpminus1 AuxiliaryFunc.gp AuxiliaryFunc.gbar AuxiliaryFunc.boundary_moments AuxiliaryFunc.CheckConvergenceSimplex AuxiliaryFunc.CheckConvergenceSD AuxiliaryFunc.MeanReturn AuxiliaryFunc.plotOptimalAssetAllocationMeanReturn AuxiliaryFunc.RiskFunction AuxiliaryFunc.BenchmarkRiskFunction AuxiliaryFunc.plotOptimalAssetAllocationRiskFunction Newton PSO ","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"CurrentModule = StochasticDominance","category":"page"},{"location":"tutorial/tutorial1/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A stochastic program is a mathematical program that involves some uncertain data. These parameters may be mostly accurately described by random variables. In most cases, it is difficult to optimize directly in terms of the distributions of these random variables. Hence, in most cases, these distributions are approximated by discrete distributions with a finite number of scenarios for the random variables. This discretization procedure is what is often called scenario generation. Uncertainty in long-term capacity planning is inescapable. The random parameters can be conceived to follow a multistage stochastic process over some time space so that the discrete scenarios represent sample paths. The approach we take is to form an approximation of the original stochastic process by discretization.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"In multistage stochastic optimization, we are interested in approximations of stochastic processes by finite structures. These processes are random and they have uncertain scenarios and a decision maker needs to make decisions at different stages of the process. It is useful to depict the possible sequences of data for this processes in form of a scenario tree in the case of a discrete time stochastic process and a scenario lattice for Markovian data processes.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is a set of nodes and branches used in models of decision making under uncertainty. Every node in the tree represents a possible state of the world at a particular point in time and a position where a decision can be made. Each tree node has a single predecessor and multiple successors whereas a lattice can have many predecessor.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree/lattice is organized in levels which corresponds to stages 1ldotsT. Each node in a stage has a specified number of predecessors as defined by the branching structure. A node represents a possible state of the stochastic process and the vertices represents the possibility of transition between the two connected nodes. A scenario tree differs from a scenario lattice by the condition that each node in stage t must have one predecessor in stage t-1. For a lattice, that is not the case; all the nodes in stage t-1 share the same children in stage t.","category":"page"},{"location":"tutorial/tutorial1/#Goal-of-StochasticDominance.jl","page":"Introduction","title":"Goal of StochasticDominance.jl","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"We model stochastic processes by scenario trees and scenario lattices. The distributions of these processes may be continuous and involves parameters that are uncertain.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The goal  of StochasticDominance.jl is to approximate the distributions of these stochastic processes by discrete distributions with finite number of scenarios of the random variables. We generate a valuated probability scenario tree or a scenario lattice which represents the stochastic process in the best way possible using the stochastic approximation algorithm. These processes are random and represent uncertainty at a particular state and at a certain point in time.  ","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"These approximations should be tractable, which is small enough to allow for reasonable calculation times, but is large enough to capture the important features of the problem. We use the concept of multistage distance to determine the quality of the approximations","category":"page"},{"location":"tutorial/tutorial1/#Introductory-example","page":"Introduction","title":"Introductory example","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Consider a simple Gaussian random walk in 5 stages. The starting value of this process is known and fixed, say at 0 and the other values are random. The following plot shows 100 sample paths of this process:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"(Image: 100 sample paths from Gaussian random walk)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"We generate and improve a scenario tree or a scenario lattice using this stochastic process. The number of iterations for the algorithm equals the number of sample paths that we want to generate from the stochastic process. Also, the number of stages in the stochastic process equals the number of stages in the scenario tree or the scenario lattice.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The user is free to choose any branching structure for the scenario tree/lattice. The branching structure shows how many branches each node in the tree has at each stage of the tree. For example, we can use a branching structure of 1x2x2x2x2 for the scenario tree. This means that each node in the tree has two children. Basically, this is a binary tree. It has been shown that the elements in the branching structure have a direct relationship with the quality of the resulting scenario tree/lattice. A scenario tree/lattice with many branches has a better approximation quality than a scenario tree with less branches.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Using the binary branching structure stated above, we obtain the following valuated probability tree that represents the above stochastic process:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"(Image: Scenario Tree 1x2x2x2x2)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Figure 1: Scenario Tree 1x2x2x2x2","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The above tree is optimal and therefore can be used by a decision maker for a decision making process depending on the type of problem he/she is handling. To measure the quality of this approximation, we use the concept of multistage distance between the stochastic process and the scenario tree or lattice, which we introduce in the following subsection.","category":"page"},{"location":"tutorial/tutorial1/#Multistage-distance","page":"Introduction","title":"Multistage distance","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"To measure the distance of stochastic processes, it is not sufficient to only consider the distance between their laws. It is also important to consider the information accumulated over time i.e., what the filtration has to tell us over time. The Wasserstein distance do not correctly separate stochastic processes having different filtration. It ignores filtration and hence does not distinguish stochastic processes. Multistage distance comes in handy in the situations for measuring distances for stochastic processes. Multistage distance is also called the process distance or nested distance.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Multistage distance was introduced by Georg Ch. Pflug (2009). It turns out that this distance is very important to measure the distance between multistage stochastic processes as it incorporates filtration introduced by the processes. We use this distance in our algorithm to measure the quality of approximation of the scenario tree and scenario lattice. Generally, a scenario tree/lattice with a minimal distance to the stochastic process is consider to have a better quality approximation.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The distance between the above scenario tree and the original process is 0.0894. This shows that the scenario tree above approximates the stochastic process well. This tree can therefore be used for decision making under uncertainty.","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-tree","page":"Introduction","title":"Description of a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is described by the following:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Name of the tree\nParents of the nodes in the tree\nChildren of the parents in the tree\nStates of the nodes in the tree\nProbabilities of transition from one node to another.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is a mutable struct of type Tree(). To create a non-optimal scenario tree, we need to fix the branching structure and the dimension of the states of nodes you are working on. The type Tree() has different methods:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"StochasticDominance\")\njulia> using StochasticDominance\njulia> methods(Tree)\n# 4 methods for generic function \"(::Type)\":\n[1] Tree(name::String, parent::Array{Int64,1},\nchildren::Array{Array{Int64,1},1}, state::Array{Float64,2}, probability::Array{Float64,2})\n[2] Tree(identifier::Int64)\n[3] Tree(spec::Array{Int64,1})\n[4] Tree(spec::Array{Int64,1}, dimension)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"All the methods correspond to the way you can create a scenario tree. For the first method, the length of states must be equal to the length of the probabilities. In the 2nd method, you can call any of our predefined trees by just calling on the identifier (these identifiers are 0, 301, 302, 303, 304, 305, 306, 307, 401, 402, 4022, 404, 405). And finally the most important methods are the 3rd and 4th method. If you know the branching structure of your scenario tree, then you can create an non-optimal starting tree using it. If you don't state the dimension you are working on, then it is defaulted into 1. For example, Tree([1,2,2,2,2]) creates a binary tree with states of dimension one as in Figure 1 above","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-lattice","page":"Introduction","title":"Description of a scenario lattice","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario lattice differs from a scenario tree in that every node in stage t is a child for each node in stage t-1. So the nodes in stage t-1 share the same children.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Due to the above, we only describe a scenario lattice by:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Name of the lattice\nStates of the nodes of the lattice\nProbabilities of transition from one node to another in the lattice","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StochasticDominance","category":"page"},{"location":"#StochasticDominance.jl","page":"Home","title":"StochasticDominance.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We present the StochasticDominance.jl package, which provides tools for analyzing higher order stochastic dominance—a method used to establish a partial order between random variables.","category":"page"},{"location":"#Brief-overview-of-stochastic-dominance","page":"Home","title":"Brief overview of stochastic dominance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stochastic dominance is a concept used to compare decision alternatives based on their cumulative risk profiles, ensuring that one alternative is preferred over another without any trade-offs across values. In the context of portfolio optimization, given a benchmark asset and a portfolio of assets, we seek an optimal allocation that maximizes a chosen objective (e.g., maximizing returns) while satisfying (higher-order) stochastic dominance constraints. ","category":"page"},{"location":"#Main-features-of-the-package","page":"Home","title":"Main features of the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StochasticDominance.jl ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The StochasticDominance.jl package provides tools to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Verify higher-order stochastic dominance – Check whether a given portfolio satisfies higher-order dominance criteria relative to a benchmark asset.\nDetermine the optimal allocation – Find the asset allocation that maximizes a chosen objective (e.g., maximizing returns) while adhering to stochastic dominance constraints. It supports two key objective functions: maximizing expected returns and minimizing higher-order risk measures.  ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package StochasticDominance.jl can be installed in Julia REPL as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"StochasticDominance\")\njulia> using StochasticDominance","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you have installed StochasticDominance.jl, we recommend going through the tutorials from beginning to end to understand how to use the package to verify stochastic dominance and determine the optimal allocation between a benchmark asset and a portfolio.","category":"page"},{"location":"#Important-functions-in-the-package","page":"Home","title":"Important functions in the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The StochasticDominance.jl package provides several important functions, which are explained in detail in the tutorials section. Here, we provide a brief overview of the functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"VerifyDominance: This function checks whether the given benchmark asset and the weighted portfolio assets exhibit a dominance relationship for the specified stochastic order. Note that the benchmark asset scenario and the weighted portfolio assets must have the same length for a valid comparison.\nStochasticDominanceMeanReturn: This function determines the optimal asset allocation that maximizes expected returns for a given stochastic order (SDorder).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, using StochasticDominanceMeanReturn(; plots=true), users can generate a pie chart displaying the optimal allocation in percentages, along with the maximized expected returns and benchmark returns. The function also includes the option StochasticDominanceMeanReturn(; verbose=true), which allows users to evaluate the convergence (or dominance) quality.","category":"page"},{"location":"","page":"Home","title":"Home","text":"StochasticDominanceRiskMeasure: This function determines the optimal asset allocation by minimizing higher-order risk measures for a given stochastic order (SDorder) while also indicating whether dominance is achieved.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, using StochasticDominanceRiskMeasure(; plots=true), users can generate a pie chart that visualizes the optimal allocation in percentages, along with the maximized expected returns and benchmark returns. The function also provides the option StochasticDominanceRiskMeasure(; verbose=true), allowing users to assess the convergence (or dominance) quality.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"CurrentModule = StochasticDominance","category":"page"},{"location":"tutorial/tutorial2/#Scenario-Trees","page":"Scenario Trees","title":"Scenario Trees","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Consider a general stochastic process X over a discrete time space T, i.e., X = (X_1dotsX_T) where X_1 is a deterministic starting value and the rest are random values or random vectors whose probability distribution is known. A scenario tree is a discrete time and discrete state process approximating the process X. We represent the scenario tree by tildeX = (tildeX_1tildeX_T). A scenario is a path from the root node to any of the leaves in the tree. The number of stages in a scenario must be equal to the number of stages in a scenario tree which is equal to the length of the sample from the stochastic process X.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"A basic scenario tree can be created using the Tree(bstructure::Array{Int64,1}, dimension::Int64) function in the package. This function takes the branching structure of the tree and the dimension of the states that you are working on. For example, consider a tree with a branching structure of 1x2x2. This is a tree with a root in stage 1, and 2 nodes in stage 2 and each of the 2 nodes in stage two has 2 nodes in stage 3 and each node has only one state and so dimension = 1.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example1 = Tree([1,2,2],1);\njulia> treeplot(example1);","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree basically is not optimal since we just randomly fill the states of the nodes of a tree with random values. This is an example of a scenario tree to begin with in stochastic approximation process. We start with a tree like this and then we use samples from a known distribution to improve the tree for a certain specified number of iterations as we shall see in the tutorials to follow.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Non optimal tree in 1D)","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree is in 1-state dimension.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The following shows the procedure to plot trees in 2 or higher dimension. We will employ the use of the function part_tree() which partitions the main tree into sub-trees of different states. For example, if the main tree is in 2 dimension, this function will return an array with two trees where the only difference is the states of the nodes of the trees. Then, we can plot each of this trees and display. Alternatively, you can use the function plot_hd which plots the trees in any dimension without partition.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example2 = Tree([1,2,2], 2);\njulia> example2Trees = part_tree(example2);\njulia> tree_plot(example2Trees[1])\njulia> savefig(\"example21.png\")\njulia> tree_plot(example2Trees[2])\njulia> savefig(\"example21.png\")","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Tree of state 1 ) (Image: Tree of state 2)\nTree of state 1 Tree of state 2","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"And in general, we can generate a tree in any d state dimension.","category":"page"},{"location":"tutorial/tutorial2/#Functions-describing-a-scenario-tree","page":"Scenario Trees","title":"Functions describing a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree can described by the following functions: nodes, stages, height, leaves and the root of the tree.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Each tree has stages starting from 1 where the root node is.","category":"page"},{"location":"tutorial/tutorial2/#Nodes-of-the-tree","page":"Scenario Trees","title":"Nodes of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"This are the vertices that are in the scenario tree. Each node in the tree has a parent node except the root node where the tree starts from. As stated before, each scenario tree is characterized by its name, parents of the nodes , children of each parent nodes e.t.c. So therefore, we have nodes which has parents and those nodes are the children of the parent nodes.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"For example,","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> nodes(example1)\n1:7","category":"page"},{"location":"tutorial/tutorial2/#Stages-of-the-tree","page":"Scenario Trees","title":"Stages of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Each node in a tree is in a specific stage and nodes in the same stage have the same number of children. The stages in a tree starts from 0 where the root node is and ends at stage T where the leaf nodes are.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> stage(example1)\n0\n1\n1\n2\n2\n2\n2","category":"page"}]
}
